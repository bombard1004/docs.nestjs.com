### 요청 라이프사이클

Nest 애플리케이션은 우리가 **요청 라이프사이클**이라고 부르는 일련의 과정을 거쳐 요청을 처리하고 응답을 생성합니다. 미들웨어, 파이프, 가드, 인터셉터를 사용하면 요청 라이프사이클 동안 특정 코드 조각이 어디에서 실행되는지 추적하기 어려울 수 있으며, 특히 전역, 컨트롤러 레벨, 라우트 레벨 컴포넌트가 사용될 때 더욱 그렇습니다. 일반적으로 요청은 미들웨어를 거쳐 가드로 이동하고, 이어서 인터셉터, 그 다음 파이프를 거친 후 반환 경로에서 인터셉터로 다시 돌아와 응답이 생성됩니다.

#### 미들웨어

미들웨어는 특정 순서로 실행됩니다. 먼저 Nest는 전역 바인딩된 미들웨어(예: `app.use`로 바인딩된 미들웨어)를 실행한 다음, 경로에 따라 결정되는 [모듈 바인딩된 미들웨어](/middleware)를 실행합니다. 미들웨어는 Express에서 미들웨어가 작동하는 방식과 유사하게 바인딩된 순서대로 순차적으로 실행됩니다. 다른 모듈에 걸쳐 바인딩된 미들웨어의 경우, 루트 모듈에 바인딩된 미들웨어가 먼저 실행되고, 그 다음에 모듈이 imports 배열에 추가된 순서대로 미들웨어가 실행됩니다.

#### 가드

가드 실행은 전역 가드부터 시작하여 컨트롤러 가드, 그리고 마지막으로 라우트 가드로 진행됩니다. 미들웨어와 마찬가지로 가드는 바인딩된 순서대로 실행됩니다. 예시:

```typescript
@UseGuards(Guard1, Guard2)
@Controller('cats')
export class CatsController {
  constructor(private catsService: CatsService) {}

  @UseGuards(Guard3)
  @Get()
  getCats(): Cats[] {
    return this.catsService.getCats();
  }
}
```

`Guard1`은 `Guard2`보다 먼저 실행되고, 둘 모두 `Guard3`보다 먼저 실행됩니다.

> info **힌트** 전역 바인딩과 컨트롤러 또는 로컬 바인딩을 구분할 때, 차이점은 가드(또는 다른 컴포넌트)가 어디에 바인딩되었는지입니다. `app.useGlobalGuard()`를 사용하거나 모듈을 통해 컴포넌트를 제공하는 경우 전역 바인딩된 것입니다. 그렇지 않은 경우, 데코레이터가 컨트롤러 클래스 앞에 있으면 컨트롤러에 바인딩된 것이고, 데코레이터가 라우트 선언 앞에 있으면 라우트에 바인딩된 것입니다.

#### 인터셉터

인터셉터는 대부분 가드와 동일한 패턴을 따르지만 한 가지 예외가 있습니다. 인터셉터가 [RxJS 옵저버블](https://github.com/ReactiveX/rxjs)을 반환하므로, 옵저버블은 선입후출(FILO) 방식으로 해결됩니다. 따라서 수신 요청은 표준적인 전역, 컨트롤러, 라우트 레벨 해결 과정을 거치지만, 요청의 응답 측면(즉, 컨트롤러 메소드 핸들러에서 반환된 후)은 라우트에서 컨트롤러, 그리고 전역 순서로 해결됩니다. 또한 파이프, 컨트롤러 또는 서비스에서 발생한 모든 오류는 인터셉터의 `catchError` 오퍼레이터에서 읽을 수 있습니다.

#### 파이프

파이프는 표준적인 전역에서 컨트롤러, 그리고 라우트 바인딩 순서를 따르며, `@UsePipes()` 매개변수에 관해서는 동일하게 선입선출(FIFO) 방식을 따릅니다. 하지만 라우트 매개변수 레벨에서는 여러 파이프가 실행되는 경우, 마지막 매개변수부터 첫 번째 매개변수까지 순서대로 실행됩니다. 이는 라우트 레벨 및 컨트롤러 레벨 파이프에도 적용됩니다. 예를 들어, 다음과 같은 컨트롤러가 있다고 가정해 봅시다.

```typescript
@UsePipes(GeneralValidationPipe)
@Controller('cats')
export class CatsController {
  constructor(private catsService: CatsService) {}

  @UsePipes(RouteSpecificPipe)
  @Patch(':id')
  updateCat(
    @Body() body: UpdateCatDTO,
    @Param() params: UpdateCatParams,
    @Query() query: UpdateCatQuery,
  ) {
    return this.catsService.updateCat(body, params, query);
  }
}
```

그러면 `GeneralValidationPipe`는 `query`, 그 다음에 `params`, 그리고 마지막으로 `body` 객체에 대해 실행된 후 `RouteSpecificPipe`로 이동하며, 이 역시 동일한 순서를 따릅니다. 만약 매개변수별 파이프가 적용되었다면, 이들은 컨트롤러 및 라우트 레벨 파이프가 실행된 후에 실행됩니다(다시 한번, 마지막 매개변수부터 첫 번째 매개변수까지).

#### 필터

필터는 전역을 먼저 해결하지 않는 유일한 컴포넌트입니다. 대신, 필터는 가능한 가장 낮은 레벨부터 해결됩니다. 즉, 실행은 라우트 바인딩된 필터부터 시작하여 컨트롤러 레벨, 마지막으로 전역 필터로 진행됩니다. 예외는 필터에서 필터로 전달될 수 없다는 점에 유의하십시오. 라우트 레벨 필터가 예외를 잡으면 컨트롤러 또는 전역 레벨 필터는 동일한 예외를 잡을 수 없습니다. 이러한 효과를 얻을 수 있는 유일한 방법은 필터 간에 상속을 사용하는 것입니다.

> info **힌트** 필터는 요청 프로세스 중에 처리되지 않은 예외가 발생한 경우에만 실행됩니다. `try/catch`와 같이 처리된 예외는 예외 필터를 실행시키지 않습니다. 처리되지 않은 예외가 발생하자마자 나머지 라이프사이클은 무시되고 요청은 필터로 직행합니다.

#### 요약

일반적으로 요청 라이프사이클은 다음과 같습니다.

1. 수신 요청
2. 미들웨어
   - 2.1. 전역 바인딩된 미들웨어
   - 2.2. 모듈 바인딩된 미들웨어
3. 가드
   - 3.1 전역 가드
   - 3.2 컨트롤러 가드
   - 3.3 라우트 가드
4. 인터셉터 (컨트롤러 전)
   - 4.1 전역 인터셉터
   - 4.2 컨트롤러 인터셉터
   - 4.3 라우트 인터셉터
5. 파이프
   - 5.1 전역 파이프
   - 5.2 컨트롤러 파이프
   - 5.3 라우트 파이프
   - 5.4 라우트 매개변수 파이프
6. 컨트롤러 (메소드 핸들러)
7. 서비스 (존재하는 경우)
8. 인터셉터 (요청 후)
   - 8.1 라우트 인터셉터
   - 8.2 컨트롤러 인터셉터
   - 8.3 전역 인터셉터
9. 예외 필터
   - 9.1 라우트
   - 9.2 컨트롤러
   - 9.3 전역
10. 서버 응답
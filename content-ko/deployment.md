### 배포

NestJS 애플리케이션을 프로덕션 환경에 배포할 준비가 되면, 가능한 효율적으로 실행되도록 보장하기 위해 취할 수 있는 핵심 단계들이 있습니다. 이 가이드에서는 NestJS 애플리케이션을 성공적으로 배포하는 데 도움이 되는 필수 팁과 모범 사례를 살펴보겠습니다.

#### 필수 조건

NestJS 애플리케이션을 배포하기 전에 다음 사항을 확인하십시오:

- 배포 준비가 완료된 동작하는 NestJS 애플리케이션이 있습니다.
- 애플리케이션을 호스팅할 수 있는 배포 플랫폼 또는 서버에 대한 액세스 권한이 있습니다.
- 애플리케이션에 필요한 모든 환경 변수가 설정되어 있습니다.
- 데이터베이스와 같이 필요한 모든 서비스가 설정되고 준비되었습니다.
- 배포 플랫폼에 Node.js LTS 버전 이상이 설치되어 있습니다.

> info **힌트** NestJS 애플리케이션을 배포할 클라우드 기반 플랫폼을 찾고 있다면, AWS에 NestJS 애플리케이션을 배포하기 위한 공식 플랫폼인 [Mau](https://mau.nestjs.com/ 'Deploy Nest')를 확인해 보세요. Mau를 사용하면 몇 번의 클릭과 단 하나의 명령 실행만으로 NestJS 애플리케이션을 쉽게 배포할 수 있습니다:
>
> ```bash
> $ npm install -g @nestjs/mau
> $ mau deploy
> ```
>
> 배포가 완료되면 몇 초 만에 AWS에서 NestJS 애플리케이션이 실행됩니다!

#### 애플리케이션 빌드하기

NestJS 애플리케이션을 빌드하려면 TypeScript 코드를 JavaScript로 컴파일해야 합니다. 이 과정은 컴파일된 파일이 포함된 `dist` 디렉토리를 생성합니다. 다음 명령을 실행하여 애플리케이션을 빌드할 수 있습니다:

```bash
$ npm run build
```

이 명령어는 일반적으로 내부적으로 `nest build` 명령을 실행합니다. 이 명령어는 기본적으로 TypeScript 컴파일러의 래퍼이며 일부 추가 기능(자산 복사 등)을 포함합니다. 사용자 지정 빌드 스크립트가 있는 경우 직접 실행할 수 있습니다. 또한 NestJS CLI 모노-리포(mono-repos)의 경우, 빌드할 프로젝트의 이름을 인자로 전달해야 합니다(`npm run build my-app`).

컴파일이 성공적으로 완료되면 프로젝트 루트에 컴파일된 파일이 포함된 `dist` 디렉토리가 보일 것이며, 진입점은 `main.js`입니다. 프로젝트의 루트 디렉토리에 `.ts` 파일이 있고 `tsconfig.json`이 이들을 컴파일하도록 구성되어 있다면, 이 파일들도 `dist` 디렉토리로 복사되어 디렉토리 구조가 약간 변경될 수 있습니다 (예: `dist/main.js` 대신 `dist/src/main.js`가 될 수 있으니 서버 구성 시 유의하세요).

#### 프로덕션 환경

프로덕션 환경은 외부 사용자가 애플리케이션에 접근할 수 있는 곳입니다. 여기에는 [AWS](https://aws.amazon.com/) (EC2, ECS 등), [Azure](https://azure.microsoft.com/), 또는 [Google Cloud](https://cloud.google.com/)와 같은 클라우드 기반 플랫폼이 포함될 수 있으며, 관리하는 전용 서버 ([Hetzner](https://www.hetzner.com/) 등)일 수도 있습니다.

배포 프로세스를 간소화하고 수동 설정을 피하기 위해, AWS에 NestJS 애플리케이션을 배포하기 위한 공식 플랫폼인 [Mau](https://mau.nestjs.com/ 'Deploy Nest')와 같은 서비스를 사용할 수 있습니다. 자세한 내용은 [이 섹션](todo)을 참조하십시오.

**클라우드 기반 플랫폼** 또는 [Mau](https://mau.nestjs.com/ 'Deploy Nest')와 같은 서비스를 사용할 때의 장점은 다음과 같습니다:

- 확장성: 사용자 기반 증가에 따라 애플리케이션을 쉽게 확장할 수 있습니다.
- 보안: 내장된 보안 기능 및 규정 준수 인증의 혜택을 받을 수 있습니다.
- 모니터링: 애플리케이션의 성능과 상태를 실시간으로 모니터링할 수 있습니다.
- 안정성: 높은 가동 시간 보장으로 애플리케이션이 항상 사용 가능하도록 보장합니다.

반면에, 클라우드 기반 플랫폼은 일반적으로 자체 호스팅보다 비용이 더 비싸고, 기본 인프라에 대한 제어력이 떨어질 수 있습니다. VPS는 보다 비용 효율적인 솔루션을 찾고 있고 서버를 직접 관리할 기술적 전문성이 있다면 좋은 선택일 수 있지만, 서버 유지 관리, 보안, 백업과 같은 작업을 수동으로 처리해야 한다는 점을 염두에 두십시오.

#### NODE_ENV=production

기술적으로 Node.js와 NestJS에서 개발 환경과 프로덕션 환경 간의 차이는 없지만, 프로덕션 환경에서 애플리케이션을 실행할 때 `NODE_ENV` 환경 변수를 `production`으로 설정하는 것은 좋은 관행입니다. 생태계의 일부 라이브러리가 이 변수에 따라 다르게 동작할 수 있기 때문입니다 (예: 디버깅 출력 활성화 또는 비활성화 등).

애플리케이션을 시작할 때 다음과 같이 `NODE_ENV` 환경 변수를 설정할 수 있습니다:

```bash
$ NODE_ENV=production node dist/main.js
```

또는 클라우드 제공업체/Mau 대시보드에서 설정할 수 있습니다.

#### 애플리케이션 실행하기

프로덕션 환경에서 NestJS 애플리케이션을 실행하려면 다음 명령을 사용하십시오:

```bash
$ node dist/main.js # 진입점 위치에 따라 조정하십시오.
```

이 명령은 애플리케이션을 시작하며, 지정된 포트(일반적으로 기본값은 `3000`)에서 수신 대기합니다. 애플리케이션에서 구성한 포트와 일치하는지 확인하십시오.

또는 `nest start` 명령을 사용할 수 있습니다. 이 명령은 `node dist/main.js`의 래퍼이지만, 한 가지 주요 차이점이 있습니다: 애플리케이션을 시작하기 전에 자동으로 `nest build`를 실행하므로, 수동으로 `npm run build`를 실행할 필요가 없습니다.

#### 헬스 체크

헬스 체크는 프로덕션 환경에서 NestJS 애플리케이션의 상태와 상황을 모니터링하는 데 필수적입니다. 헬스 체크 엔드포인트를 설정함으로써, 앱이 예상대로 실행되고 있는지 정기적으로 확인하고 문제가 심각해지기 전에 대응할 수 있습니다.

NestJS에서는 **@nestjs/terminus** 패키지를 사용하여 헬스 체크를 쉽게 구현할 수 있습니다. 이 패키지는 데이터베이스 연결, 외부 서비스, 사용자 지정 체크를 포함한 헬스 체크를 추가하기 위한 강력한 도구를 제공합니다.

NestJS 애플리케이션에 헬스 체크를 구현하는 방법을 배우려면 [이 가이드](/recipes/terminus)를 확인하고, 앱이 항상 모니터링되고 응답 가능한 상태인지 확인하세요.

#### 로깅

로깅은 모든 프로덕션 준비 애플리케이션에 필수적입니다. 오류를 추적하고, 동작을 모니터링하며, 문제를 해결하는 데 도움이 됩니다. NestJS에서는 내장 로거를 사용하여 로깅을 쉽게 관리하거나, 더 고급 기능이 필요한 경우 외부 라이브러리를 선택할 수 있습니다.

로깅을 위한 모범 사례:

- 예외가 아닌 오류 로깅: 디버깅 및 문제 해결 속도를 높이기 위해 상세한 오류 메시지 로깅에 집중합니다.
- 민감한 데이터 회피: 보안을 보호하기 위해 비밀번호나 토큰과 같은 민감한 정보를 절대 로깅하지 마십시오.
- 상관관계 ID 사용: 분산 시스템에서는 서로 다른 서비스 간에 요청을 추적하기 위해 고유 식별자(예: 상관관계 ID)를 로그에 포함시킵니다.
- 로그 레벨 사용: 심각도별로 로그를 분류하고(예: `info`, `warn`, `error`) 프로덕션 환경에서는 디버그 또는 상세 로그를 비활성화하여 노이즈를 줄입니다.

> info **힌트** [AWS](https://aws.amazon.com/) ([Mau](https://mau.nestjs.com/ 'Deploy Nest') 또는 직접 사용)를 사용하고 있다면, 로그를 더 쉽게 파싱하고 분석할 수 있도록 JSON 로깅을 고려하십시오.

분산 애플리케이션의 경우, ElasticSearch, Loggly, Datadog과 같은 중앙 집중식 로깅 서비스를 사용하는 것이 매우 유용할 수 있습니다. 이러한 도구는 로그 집계, 검색, 시각화와 같은 강력한 기능을 제공하여 애플리케이션의 성능과 동작을 더 쉽게 모니터링하고 분석할 수 있습니다.

#### 스케일 업 또는 스케일 아웃

NestJS 애플리케이션을 효과적으로 확장하는 것은 트래픽 증가를 처리하고 최적의 성능을 보장하는 데 중요합니다. 스케일링에는 **수직 확장(vertical scaling)**과 **수평 확장(horizontal scaling)**이라는 두 가지 주요 전략이 있습니다. 이러한 접근 방식을 이해하면 부하를 효율적으로 관리하도록 애플리케이션을 설계하는 데 도움이 됩니다.

**수직 확장**은 흔히 "스케일 업(scaling up)"이라고 불리며, 성능 향상을 위해 단일 서버의 리소스를 늘리는 것을 포함합니다. 이는 기존 머신에 CPU, RAM, 또는 스토리지를 더 추가하는 것을 의미할 수 있습니다. 고려해야 할 몇 가지 핵심 사항은 다음과 같습니다:

- 단순성: 수직 확장은 여러 인스턴스를 관리하는 대신 기존 서버만 업그레이드하면 되므로 일반적으로 구현이 더 간단합니다.
- 제한 사항: 단일 머신을 확장할 수 있는 물리적 한계가 있습니다. 최대 용량에 도달하면 다른 옵션을 고려해야 할 수 있습니다.
- 비용 효율성: 중간 정도의 트래픽을 가진 애플리케이션의 경우, 추가 인프라의 필요성을 줄이기 때문에 수직 확장이 비용 효율적일 수 있습니다.

예시: NestJS 앱이 가상 머신에 호스팅되어 있고 피크 시간 동안 느리게 실행되는 것을 알게 되면, 더 많은 리소스를 가진 더 큰 인스턴스로 VM을 업그레이드할 수 있습니다. VM을 업그레이드하려면 현재 제공업체의 대시보드로 이동하여 더 큰 인스턴스 유형을 선택하기만 하면 됩니다.

**수평 확장**, 또는 "스케일 아웃(scaling out)"은 부하를 분산하기 위해 더 많은 서버 또는 인스턴스를 추가하는 것을 포함합니다. 이 전략은 클라우드 환경에서 널리 사용되며 높은 트래픽을 예상하는 애플리케이션에 필수적입니다. 이점 및 고려 사항은 다음과 같습니다:

- 용량 증가: 애플리케이션 인스턴스를 더 추가함으로써 성능 저하 없이 더 많은 수의 동시 사용자를 처리할 수 있습니다.
- 중복성: 수평 확장은 중복성을 제공합니다. 하나의 서버가 실패하더라도 전체 애플리케이션이 중단되지 않습니다. 트래픽은 나머지 서버들 사이에 재분배될 수 있습니다.
- 로드 밸런싱: 여러 인스턴스를 효과적으로 관리하기 위해 로드 밸런서(예: Nginx 또는 AWS Elastic Load Balancing)를 사용하여 수신 트래픽을 서버 전체에 고르게 분산합니다.

예시: 높은 트래픽을 겪고 있는 NestJS 애플리케이션의 경우, 클라우드 환경에 앱의 여러 인스턴스를 배포하고 로드 밸런서를 사용하여 요청을 라우팅함으로써 단일 인스턴스가 병목 현상이 되지 않도록 보장할 수 있습니다.

이 프로세스는 [Docker](https://www.docker.com/)와 같은 컨테이너화 기술과 [Kubernetes](https://kubernetes.io/)와 같은 컨테이너 오케스트레이션 플랫폼을 사용하면 간단합니다. 또한 [AWS Elastic Load Balancing](https://aws.amazon.com/elasticloadbalancing/) 또는 [Azure Load Balancer](https://azure.microsoft.com/en-us/services/load-balancer/)와 같은 클라우드별 로드 밸런서를 활용하여 애플리케이션 인스턴스 전체에 트래픽을 분산시킬 수 있습니다.

> info **힌트** [Mau](https://mau.nestjs.com/ 'Deploy Nest')는 AWS에서의 수평 확장을 위한 내장 지원을 제공하여, 몇 번의 클릭만으로 NestJS 애플리케이션의 여러 인스턴스를 쉽게 배포하고 관리할 수 있습니다.

#### 기타 팁

NestJS 애플리케이션을 배포할 때 염두에 두어야 할 몇 가지 추가 팁이 있습니다:

-   **보안**: SQL 주입, XSS 등 일반적인 위협으로부터 애플리케이션이 안전하게 보호되는지 확인하십시오. 자세한 내용은 "보안" 범주를 참조하십시오.
-   **모니터링**: [Prometheus](https://prometheus.io/) 또는 [New Relic](https://newrelic.com/)과 같은 모니터링 도구를 사용하여 애플리케이션의 성능과 상태를 추적하십시오. 클라우드 제공업체/Mau를 사용하는 경우, 내장된 모니터링 서비스([AWS CloudWatch](https://aws.amazon.com/cloudwatch/) 등)를 제공할 수 있습니다.
-   **환경 변수 하드코딩 금지**: API 키, 비밀번호, 토큰과 같은 민감한 정보를 코드에 하드코딩하지 마십시오. 환경 변수 또는 시크릿 매니저를 사용하여 이러한 값을 안전하게 저장하고 액세스하십시오.
-   **백업**: 사고 발생 시 데이터 손실을 방지하기 위해 정기적으로 데이터를 백업하십시오.
-   **배포 자동화**: CI/CD 파이프라인을 사용하여 배포 프로세스를 자동화하고 환경 간 일관성을 보장하십시오.
-   **속도 제한**: 남용을 방지하고 DDoS 공격으로부터 애플리케이션을 보호하기 위해 속도 제한을 구현하십시오. 자세한 내용은 [속도 제한 챕터](/security/rate-limiting)를 확인하거나, 고급 보호를 위해 [AWS WAF](https://aws.amazon.com/waf/)와 같은 서비스를 사용하십시오.

#### 애플리케이션 Dockerize하기

[Docker](https://www.docker.com/)는 개발자가 애플리케이션을 해당 종속성과 함께 컨테이너라는 표준 단위로 패키징할 수 있도록 컨테이너화를 사용하는 플랫폼입니다. 컨테이너는 가볍고 이식성이 뛰어나며 격리되어 있어 로컬 개발부터 프로덕션까지 다양한 환경에 애플리케이션을 배포하는 데 이상적입니다.

NestJS 애플리케이션을 Dockerize할 때의 이점:

- 일관성: Docker는 애플리케이션이 어떤 머신에서든 동일하게 실행되도록 보장하여 "내 컴퓨터에서는 되는데?" 문제를 해결합니다.
- 격리: 각 컨테이너는 격리된 환경에서 실행되어 종속성 간의 충돌을 방지합니다.
- 확장성: Docker는 서로 다른 머신 또는 클라우드 인스턴스에서 여러 컨테이너를 실행하여 애플리케이션을 쉽게 확장할 수 있게 합니다.
- 이식성: 컨테이너는 환경 간에 쉽게 이동할 수 있어 다른 플랫폼에 애플리케이션을 쉽게 배포할 수 있습니다.

Docker를 설치하려면 [공식 웹사이트](https://www.docker.com/get-started)의 지침을 따르십시오. Docker가 설치되면 NestJS 프로젝트에 `Dockerfile`을 생성하여 컨테이너 이미지를 빌드하는 단계를 정의할 수 있습니다.

`Dockerfile`은 Docker가 컨테이너 이미지를 빌드하는 데 사용하는 지침이 포함된 텍스트 파일입니다.

NestJS 애플리케이션을 위한 샘플 Dockerfile은 다음과 같습니다:

```bash
# 공식 Node.js 이미지를 기본 이미지로 사용
FROM node:20

# 컨테이너 내부 작업 디렉토리 설정
WORKDIR /usr/src/app

# package.json 및 package-lock.json을 작업 디렉토리로 복사
COPY package*.json ./

# 애플리케이션 종속성 설치
RUN npm install

# 나머지 애플리케이션 파일 복사
COPY . .

# NestJS 애플리케이션 빌드
RUN npm run build

# 애플리케이션 포트 노출
EXPOSE 3000

# 애플리케이션 실행 명령어
CMD ["node", "dist/main"]
```

> info **힌트** `node:20`을 프로젝트에서 사용하는 적절한 Node.js 버전으로 바꾸세요. 사용 가능한 Node.js Docker 이미지는 [공식 Docker Hub 저장소](https://hub.docker.com/_/node)에서 찾을 수 있습니다.

이것은 Node.js 환경을 설정하고, 애플리케이션 종속성을 설치하고, NestJS 애플리케이션을 빌드하고 실행하는 기본 Dockerfile입니다. 프로젝트 요구 사항에 따라 이 파일을 사용자 지정할 수 있습니다 (예: 다른 기본 이미지 사용, 빌드 프로세스 최적화, 프로덕션 종속성만 설치 등).

또한 Docker가 이미지를 빌드할 때 무시해야 할 파일 및 디렉토리를 지정하는 `.dockerignore` 파일을 생성하겠습니다. 프로젝트 루트에 `.dockerignore` 파일을 생성하십시오:

```bash
node_modules
dist
*.log
*.md
.git
```

이 파일은 불필요한 파일이 컨테이너 이미지에 포함되지 않도록 보장하여 이미지를 가볍게 유지합니다. 이제 Dockerfile이 설정되었으므로 Docker 이미지를 빌드할 수 있습니다. 터미널을 열고 프로젝트 디렉토리로 이동하여 다음 명령을 실행하십시오:

```bash
docker build -t my-nestjs-app .
```

이 명령어에서:

-   `-t my-nestjs-app`: 이미지를 `my-nestjs-app`라는 이름으로 태그합니다.
-   `.`: 현재 디렉토리를 빌드 컨텍스트로 지정합니다.

이미지를 빌드한 후에는 컨테이너로 실행할 수 있습니다. 다음 명령을 실행하십시오:

```bash
docker run -p 3000:3000 my-nestjs-app
```

이 명령어에서:

-   `-p 3000:3000`: 호스트 머신의 3000번 포트를 컨테이너의 3000번 포트에 매핑합니다.
-   `my-nestjs-app`: 실행할 이미지를 지정합니다.

이제 NestJS 애플리케이션이 Docker 컨테이너 내부에서 실행되어야 합니다.

Docker 이미지를 클라우드 제공업체에 배포하거나 다른 사람과 공유하려면 Docker 레지스트리([Docker Hub](https://hub.docker.com/), [AWS ECR](https://aws.amazon.com/ecr/), 또는 [Google Container Registry](https://cloud.google.com/container-registry) 등)에 푸시해야 합니다.

레지스트리를 선택했다면 다음 단계에 따라 이미지를 푸시할 수 있습니다:

```bash
docker login # Docker 레지스트리에 로그인
docker tag my-nestjs-app your-dockerhub-username/my-nestjs-app # 이미지 태그 지정
docker push your-dockerhub-username/my-nestjs-app # 이미지 푸시
```

`your-dockerhub-username`을 Docker Hub 사용자 이름 또는 해당 레지스트리 URL로 바꾸십시오. 이미지를 푸시한 후에는 어떤 머신에서든 이미지를 풀(pull)하여 컨테이너로 실행할 수 있습니다.

AWS, Azure, Google Cloud와 같은 클라우드 제공업체는 컨테이너를 대규모로 배포하고 관리하는 것을 단순화하는 관리형 컨테이너 서비스를 제공합니다. 이러한 서비스는 자동 확장, 로드 밸런싱, 모니터링과 같은 기능을 제공하여 프로덕션 환경에서 NestJS 애플리케이션을 더 쉽게 실행할 수 있도록 합니다.

#### Mau를 사용한 쉬운 배포

[Mau](https://mau.nestjs.com/ 'Deploy Nest')는 [AWS](https://aws.amazon.com/)에 NestJS 애플리케이션을 배포하기 위한 공식 플랫폼입니다. 인프라를 수동으로 관리할 준비가 되지 않았거나 시간을 절약하고 싶다면 Mau가 완벽한 솔루션입니다.

Mau를 사용하면 인프라 프로비저닝 및 유지는 몇 번의 클릭만큼 간단합니다. Mau는 간단하고 직관적으로 설계되어, 애플리케이션 구축에 집중하고 기본 인프라에 대해 걱정할 필요가 없습니다. 내부적으로는 **Amazon Web Services**를 사용하여 강력하고 안정적인 플랫폼을 제공하면서 AWS의 모든 복잡성을 추상화합니다. 우리는 모든 무거운 작업을 대신 처리하므로, 애플리케이션 구축 및 비즈니스 성장에 집중할 수 있습니다.

[Mau](https://mau.nestjs.com/ 'Deploy Nest')는 스타트업, 중소기업, 대기업, 그리고 인프라 학습 및 관리에 많은 시간을 투자하지 않고도 빠르게 시작하려는 개발자에게 완벽합니다. 사용이 매우 쉽고, 몇 분 안에 인프라를 가동할 수 있습니다. 또한 백그라운드에서 AWS를 활용하여 AWS의 복잡성을 관리하는 번거로움 없이 AWS의 모든 이점을 누릴 수 있습니다.

<figure><img src="/assets/mau-metrics.png" /></figure>

[Mau](https://mau.nestjs.com/ 'Deploy Nest')를 사용하면 다음을 수행할 수 있습니다:

- 몇 번의 클릭만으로 NestJS 애플리케이션 (API, 마이크로서비스 등)을 배포합니다.
- 다음과 같은 **데이터베이스**를 프로비저닝합니다:
  - PostgreSQL
  - MySQL
  - MongoDB (DocumentDB)
  - Redis
  - 더 많은 서비스
- 다음과 같은 브로커 서비스를 설정합니다:
  - RabbitMQ
  - Kafka
  - NATS
- 예약 작업 (**CRON jobs**) 및 백그라운드 워커를 배포합니다.
- 람다 함수 및 서버리스 애플리케이션을 배포합니다.
- 자동화된 배포를 위한 **CI/CD 파이프라인**을 설정합니다.
- 그리고 훨씬 더 많습니다!

Mau로 NestJS 애플리케이션을 배포하려면 다음 명령을 실행하십시오:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```

지금 가입하고 [Mau로 배포](https://mau.nestjs.com/ 'Deploy Nest')하여 몇 분 안에 AWS에서 NestJS 애플리케이션을 가동하세요!
